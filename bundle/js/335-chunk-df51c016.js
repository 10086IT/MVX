"use strict";(self.webpackChunkusersores=self.webpackChunkusersores||[]).push([[335],{63335:function(n,e,t){t.r(e),t.d(e,{default:function(){return f}});t(41539),t(12419);var a=t(15671),i=t(43144),l=t(79340),r=t(82963),o=t(61120),c=t(67294),u=t(36112);function s(n){var e=function(){if("undefined"==typeof Reflect||!Reflect.construct)return!1;if(Reflect.construct.sham)return!1;if("function"==typeof Proxy)return!0;try{return Boolean.prototype.valueOf.call(Reflect.construct(Boolean,[],(function(){}))),!0}catch(n){return!1}}();return function(){var t,a=(0,o.Z)(n);if(e){var i=(0,o.Z)(this).constructor;t=Reflect.construct(a,arguments,i)}else t=a.apply(this,arguments);return(0,r.Z)(this,t)}}var f=function(n){(0,l.Z)(t,n);var e=s(t);function t(){return(0,a.Z)(this,t),e.apply(this,arguments)}return(0,i.Z)(t,[{key:"render",value:function(){return c.createElement(u.v5,null,'# java 笔记\n\n## 1、命名规范\n\n- 包名命名: 统一使用小写字母\n- 类命名: 大驼峰命名形式，即单词的首字母大写\n- 方法名: 方法命名采用小驼峰的形式，首字母小写\n- 常量名: 常量名采用全部大写的形式\n- 名称只能由字母、数字、下划线、$符号等组成,，但不能以数字开头\n- 名称不能使用JAVA中的关键字\n- 最好用英文, 防止污染博大精深的中国文化\n\n## 2、数据结构\n\n1、 线性表（ArrayList\n\n```java\npublic interface List<E> extends Iterable<E> {\n    public void add(E element);//默认从尾部添加元素\n    public void add(int index,E element);//在指定位置添加元素\n    public void remove(E element);//默认删除尾部元素\n    public E remove(int index);//删除指定位置的元素\n    public E get(int index);//获取下标为index的元素\n    public E set(int index, E element);//修改指定位置的元素的值\n    public int size();//有效数据的长度\n    public int indexOf(E element);//查找元素element的位置，返回其下标\n    public boolean contains(E element);//判断是否包含element\n    public boolean isEmpty();//判断该线性表是否为空\n    public void clear();//清空该线性表\n    public void sort(Comparator<E> comparator);//对该线性表进行排序\n    public List<E> subList(int fromIndex, int toIndex);//获取一个从fromIndex到toIndex的字线性表\n}\n\n```\n\n2、 链表（LinkedList）\n\n3、 栈（Stack）\n\n4、 队列（Queue）\n\n5、 图（Map）\n\n6、 树（Tree）\n\n## 3、类与对象的关系\n\n类是对象的抽象，对象是类的具体，类是对象的模板，对象是类的实例\n\n## 4、Java中有几种数据类型\n> byte、short、int、long、float、double、 char、boolean\n\n整形：byte,short,int,long\n\n> integer的默认值是null，int的默认值是0\n\n浮点型：float,double\n\n字符型：char\n\n> har在java中也是比较特殊的类型，它的int值从1开始，一共有2的16次方个数据；\n  Char<int<long<float<double；Char类型可以隐式转成int,double类型，但是不能隐式转换成string；如果char类\n  型转成byte，short类型的时候，需要强转。\n\n布尔型：boolean\n\n## 5、instanceof关键字的作用\ninstanceof 严格来说是Java中的一个双目运算符，用来测试一个对象是否为一个类的实例\n\n```java\nboolean result = obj instanceof Class\n```\n其中 obj 为一个对象，Class 表示一个类或者一个接口，当 obj 为 Class 的对象，或者是其直接或\n间接子类，或者是其接口的实现类，结果result 都返回 true，否则返回false。\n注意：编译器会检查 obj 是否能转换成右边的class类型，如果不能转换则直接报错，如果不能确定\n类型，则通过编译，具体看运行时定。\n\n## 6、==  && equals\n### ==\n- 在Java中，如果是基本数据类型，则 == 比较的是值；如果是对象类型，则 == 比较的是对象的地址。\n- 比较的是变量(栈)内存中存放的对象的(堆)内存地址，用来判断两个对象的地址是否相同，即是否是\n  指相同一个对象。比较的是真正意义上的指针操作。\n  \n  1、比较的是操作符两端的操作数是否是同一个对象。\n  \n  2、两边的操作数必须是同一类型的（可以是父子类之间）才能编译通过。\n  \n  3、比较的是地址，如果是具体的阿拉伯数字的比较，值相等则为true\n  \n### quals：\n- equals用来比较的是两个对象的内容是否相等，由于所有的类都是继承自java.lang.Object类的，所以\n适用于所有对象，如果没有对该方法进行覆盖的话，调用的仍然是Object类中的方法，而Object中的\nequals方法返回的却是==的判断。  \n##  7、字符串常量池\n\nString类是我们平常项目中使用频率非常高的一种对象类型，JVM为了提升性能和减少开销，避免字符串的重复创建，维护了一块特殊的内存空间，即字符串常量池。当需要使用字符串时，先去字符串常量池查看该字符串是否已经存在，如果存在，则可直接使用；如果不存在，初始化，并将该字符串放入到字符串常量池中。\n\n## 8、包装类\nbyte：Byte，short：Short，int：Integer，long：Long，float：Float，double：Double，char：Character ，boolean：Boolean\n\n## 9、用Bigdecimal类进行浮点型数据的运算\nBigDecimal.setScale\n\n## 10、面向对象的特征\n\n### 抽象:\n    抽象是将一类对象的共同特征总结出来构造类的过程, 包括数据抽象和行为抽象两方面。抽象只关注对象有哪些属\n    性和行为,并不关注这些行为的细节是什么。\n### 继承\n继承是从已有类得到继承信息创建新类的过程.提供继承信息的类被称为父类(超类、基类) ;得到继承信息的类被称\n    为子类(派生类)。继承让变化中的软件系统有了一定的延续性 ,同时继承也是封装程序中可变因素的重要手段。\n    \n### 封装：\n封装就是隐藏一切可隐藏的东西，只向外界提供最简单的编程接口\n\n### 多态性\n多态性是指允许不同子类型的对象对同一消息作出不同的响应。\n\n### 重写(Override)\n\n子类函数的访问修饰权限不能少于父类的\n\n### 重载（Overload）\n    在一个类中，同名的方法如果有不同的参数列表（参数类型不同、参数个数不同甚至是参数顺序不同）\n    则视为重载。同时，重载对返回类型没有要求，可以相同也可以不同，但不能通过返回类型是否相同来\n    判断重载。\n## 11、 访问修饰符\n- 当前类： public protected default private\n \n- 同包： public protected default\n \n- 子类：  public protected \n \n- 其他包： public\n\n## 12、Java常用包\n\n> Java.lang\n  Java.io\n  Java.sql\n  Java.util\n  Java.awt\n  Java.net\n  Java.math\n  \n## 13、Object类常用方法\n```text\nEquals\nHashcode\ntoString\nwait\nnotify\nclone\ngetClass\n```\n## 14、 形参与实参\n而如果函数的参数是指针类型变量,在调用该函数的过程中，传给函数的是实参的地址，在函数体内部使用的也是实参的地址，即使用的就是实参\n本身。所以在函数体内部可以改变实参的值\n\n## 15、 Static\n- Static修饰的方法是静态方法，表示该方法属于当前类的，而不属于某个对象的，静态方法也不能被重写，可以直接使用类名来调用。在\nstatic方法中s不能使用this或者super关键字。\n\n- static修饰变量是静态变量或者叫类变量，静态变量被所有实例所共享，不会依赖于对象。静态变量在内存中只有一份拷贝，在JVM加载类\n的时候，只为静态分配一次内存。\n\n## 16、final\ninal也是很多面试喜欢问的地方,但我觉得这个问题很无聊,通常能回答下以下5点就不错了:\n1.  被final修饰的类不可以被继承\n2.  被final修饰的方法不可以被重写\n3.  被final修饰的变量不可以被改变.如果修饰引用,那么表示引用不可变,引用指向的内容可变.\n4.  被final修饰的方法,JVM会尝试将其内联,以提高运行效率\n5.  被final修饰的常量,在编译阶段会存入常量池中.\n除此之外,编译器对final域要遵守的两个重排序规则更好:\n在构造函数内对一个final域的写入,与随后把这个被构造对象的引用赋值给一个引用变量,这两个操作之间不能重排序\n初次读一个包含final域的对象的引用,与随后初次读这个final域,这两个操作之间不能重排序\n\n## 17、垃圾回收\n\n- String\n```text\nJava的四种引用，强弱软虚\n强引用\n强引用是平常中使用最多的引用，强引用在程序内存不足（OOM）的时候也不会被回收，使用方式：String str = new String("str");\n\n软引用\n软引用在程序内存不足时，会被回收\n可用场景： 创建缓存的时候，创建的对象放进缓存中，当内存不足时，JVM就会回收早先创建的对象。\n弱引用\n弱引用就是只要JVM垃圾回收器发现了它，就会将之回收，\n\n可用场景：Java源码中的java.util.WeakHashMap中的key就是使用弱引用，我的理解就是，\n一旦我不需要某个引用，JVM会自动帮我处理它，这样我就不需要做其它操作。\n虚引用\n虚引用的回收机制跟弱引用差不多，但是它被回收之前，会被放入ReferenceQueue中。注意哦，其它引用是被JVM回收后才被传入\nReferenceQueue中的。由于这个机制，所以虚引用大多被用于引用销毁前的处理工作。还有就是，虚引用创建的时候，必须带有\nReferenceQueue，使用\n例子：\n可用场景： 对象销毁前的一些操作，比如说资源释放等。** Object.finalize() 虽然也可以做这类动作，但是这个方式即不安全又低效\n上诉所说的几类引用，都是指对象本身的引用，而不是指 Reference 的四个子类的引用\n( SoftReference 等)。\n```\n\n## 18、 jdbc\n- 加载数据库驱动类\n- 打开数据库连接\n- 执行sql语句\n- 处理返回结果\n- 关闭资源\n- 使用PreparedStatement类，而不是使用Statement类，防止出现sql注入\n\n\n\n\n\n\n\n')}}]),t}(c.Component)}}]);